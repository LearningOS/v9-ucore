#ucore在v9-CPU上的移植
**韩旭 徐磊**

## 概述
将ucore移植到v9-CPU上是我们组课程设计的核心内容。根据我们的设想，我们将完成ucore代码（包含了lab1~lab8）在v9-CPU上的移植工作，我们进一步的希望能实现更多的操作系统内存管理、进程管理的策略算法，并能够提供更好的实验是指导书。

由于对于代码移植部分的困难估计不足，因此目前只完成了实验的主体部分，即代码移植。目前我们已经将ucore移植到v9-CPU上，相关代码可以较为稳定的运行。我们将8个实验进行了一定的合并，合并之后的包括了6个实验。目前移植的实验和ucore保持功能一致，但在某些硬件相关的部分没有完全按照ucore的抽象层次实现，这样可以保持程序的简单。

## 相关工作介绍

**[swieros](https://github.com/rswier/swieros)** 是v9-CPU的原型，作者设计了一个兼具RISC和SISC特性的指令集，并为指令集实现了一个简化的C编译器以及相应的模拟器。作者在这套框架上移植了xv6教学操作系统，但是受限于编译器和模拟器，xv6被较多的修改，而且在实现上也有一些不太合理的地方。

**[ucore](https://github.com/chyyuu/ucore_os_lab)** 是清华大学操作系统课程采用的教学操作系统，这套操作系统具有较为完善的抽象层次和代码结构，操作系统被拆分成了8个lab，每个lab都在前一个lab上进行了一些修改和加入了新的功能。比较适合增量开发，但是这样的开发也可能造成一些麻烦。

**[v9.js](https://github.com/JianxinMa/v9.js)** 是今年课程设计另一个小组的工作，它把v9的编译器和调试器都移植到javascript上，这样就可以有一个在浏览器上的运行环境。我们希望我们移植之后的操作系统可以在他们提供的平台上运行。

**[alex-machine](https://github.com/paulzfm/alex-machine)** 参考v9定义的新指令集和模拟器。

**[alex-llvm](https://github.com/a1exwang/llvm)** 采用LLVM作为C语言的编译器，这样就可以使用标准的C进行操作系统的编程而不必考虑编译器带来的各种局限。因为alex与v9非常类似，将来可能可以把v9-ucore通过比较少的修改移植到alex-machine上。

## 实现方案

我们采取的方案核心思路是：

- 保持代码结构ucore内核基本一致
- 和硬件相关功能参考xv6的实现，采用较为简单的方法实现
- 合并相关lab，保留一部分中间结果，但避免多次lab之间的迁移的麻烦

## 主要难点

**非标准编译器带来的麻烦**

- 编译器不支持const，使用const编译器不仅不会报错，而且会产生难以预期的结果，因此这一问题一定要加以注意。
- 编译器不支持宏定义，只支持一层include，这会带来很多工程上的问题，我们使用GCC的代码预处理器解决了这个问题。这样所有宏定义都有了支持，而且可以比较好的处理复杂的引用关系。经过预处理后的程序是一个单独的文件，更加简单，更有可能复合已有编译器的要求。
- 编译器对于函数的声明和定义有一定的限制。在标准C中，函数可以在任意位置声明任意多次，但是在现有的编译器上，函数声明只能出现在定义之前，且只能有一次，这个问题编译器会报错，因此稍加修改就可以避免。
- 编译器不支持链接，所以需要讲所有的函数都写在头文件中，这样很容易出现多个头文件循环依赖的情况，这时候就需要对文件结构进行一些修改，把函数的声明单独抽象成一个头文件。
- 编译器支持函数指针，但是写法比较特殊，我们到实验的后期才发现了这个特性，所以我们使用了一些特殊的方法手动修改调用栈，实现了相关功能。

**硬件相关的代码**

- 操作系统底层有很多与硬件密切相关的代码，这部分代码随着平台的切换就需要完全的进行修改。实验的核心也就是修改这部分代码。
- X86作为SISC，硬件能提供很多复杂的功能，我们需要使用多条指令对单指令进行替换，这时候就需要考虑原子操作的问题，我们使用开关中断处理这一问题。
- 寄存器的问题，v9-CPU上只有3个寄存器，在系统调用时可能出现传参数不够用的情况，我们使用传指针解决这个问题，这样会造成一些系统调用的接口有所变化，以及一些代码不一致产生的问题。
- 某些硬件的接口完全是不同的，例如X86上磁盘采用寄存器控制，而v9-CPU上，磁盘是一块被映射的内存，两者采用的文件系统也是完全不同的，这是需要将xv6中的相关驱动移植到ucore里。

**ucore中复杂的抽象层次**

- 一个显著的例子是文件系统，ucore中的文件系统使用Linux内核中移植的，非常复杂，很难修改支持硬件。我们直接使用了xv6中的驱动，在系统调用层面把文件系统和内核的其它部分做了接口的转换。

## 开发过程

**Lab1-Lab2**

**Lab3**

**Lab4-Lab5**

**Lab6**

**Lab7**

**Lab8**

## 实验总结
